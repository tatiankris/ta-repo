///У Observable есть метод pipe, в котором можно выполнять всякие Pipeable операторы.
//observable.pipe(...) всегда возвращает Observable.
//Он не меняет первоначальный observable, а лишь создает новый на основе первоначального.

//1
// observable
//        .pipe(map((x) => x * x))
//        .subscribe((v) => console.log(`value: ${v}`));

//2
//observable2 = observable
//         .pipe(map((x) => x * x));
//
//subscription = observable2.subscribe((v) => console.log(v));

//3
//observable.pipe(op1(), op2(), op3(), op4()); --- операторы выполняются последовательно внутри pipe


//Pipeable OPERATORS

// 1. Фильтрация (Filtering)
// Операторы для выборочной эмиссии значений:
//
// filter(): Фильтрует значения по условию.
//
// take(): Берет первые n значений и завершает поток.
//
// takeUntil(notifier): Эмитит значения до эмиссии notifier.
//
// takeWhile(): Берет значения, пока условие истинно.
//
// skip(): Пропускает первые n значений.
//
// skipUntil(notifier): Пропускает значения до эмиссии notifier.
//
// skipWhile(): Пропускает значения, пока условие истинно.
//
// first(): Берет первое значение (с опциональным условием).
//
// last(): Берет последнее значение.
//
// elementAt(): Берет значение по индексу эмиссии.
//
// distinct(): Игнорирует дубликаты (по значению).
//
// distinctUntilChanged(): Игнорирует повторяющиеся подряд значения.
//
// throttle(): Эмитит первое значение, затем игнорирует новые в течение времени.
//
// debounce(): Ждет паузы в эмиссиях перед эмиссией последнего значения.
//
// audit(): Игнорирует значения в течение времени, затем эмитит последнее.
