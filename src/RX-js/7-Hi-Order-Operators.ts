import {filter, map, of} from "rxjs";

///В RxJS все операторы возвращают Observable, но есть разница в том, что эти Observable эмитят:

//Эмитят - отправляют в subscriber.next( value )
// value - может быть значением(42, "hello", {}), а может быть Observable.


///Большинство операторов преобразуют поток и эмитят обычные значения:

of(1, 2, 3).pipe(
    map(x => x * 2),       // Эмитит числа: 2, 4, 6
    filter(x => x > 3)     // Эмитит числа: 4, 6
).subscribe(console.log);


///Некоторые операторы возвращают потоки, которые сами эмитят другие потоки:

// Flattering операторы - автоматически подписываются - subscribe() - на потоки(Observables), которые они эмитят,
// чтобы мы сразу получали значения возвращаемых(заэмиченых) потоков(Observables).

const flatteringOperators = {

    switchMap: `При получении нового значения:
    - отписывается от старого возвращаемого(эмиченного) Observable,
    - создает новый Observable из полученного значения,
    - подписывается на новый Observable и эмитит его значения.
    `,

    mergeMap: `При получении нового значения:
    - создает новый Observable из полученного значения,
    - подписывается на новый Observable и эмитит его значения,
    - в результате он подписан на ВСЕ Observables из ВСЕХ пришедших значений, (внутри использ merge? он их всех мержит?)
    - И далее эмитит значения из ВМЕХ Observables них по мере их поступления.
    `,

    concatMap: `При получении нового значения:
    - cтавит новый Observable из нового значения в очередь,
    - дожидается завершения текущего Observable,
    - подписывается на следующий Observable из очереди,
    При этом порядок пришедших значений СОХРАНЯЕТСЯ.
    `,

    exhaustMapMy: `При получении нового значения:
    - eсли текущий Observable активен - игнорирует новое значение,
    - если текущий Observable завершен - создает новый Observable,
    - подписывается на него и эмитит его значения.    
    `,
}





///merge, concat
//distinctUntil
