///Мощь RxJS проистекает из того, что он построен на основе столпов функционального и реактивного программирования,
// а также нескольких популярных шаблонов проектирования,
// таких как Observer(наблюдатель) и Iterator(итератор), которые успешно используются годами.


//Конечно, RxJS не изобрел эти шаблоны, но он нашел способы использовать их в контексте функционального программирования.

///Кроме того, для обозначения переменных, указывающих на потоки, часто используется $суффикс. В сообществе RxJS это известно как финская нотация,
// приписываемая Андре Штальцу, одному из основных разработчиков RxJS и финского языка.

//Observer pattern
///В основе RxJS лежит тонко настроенный шаблон проектирования «Наблюдатель». Он включает в себя объект (субъект),
// который хранит список подписчиков (каждый из которых является наблюдателем), уведомляемых о любых изменениях состояния.

//Однако у элементарного шаблона «Наблюдатель» есть свои недостатки из-за утечек памяти, связанных с неправильным удалением наблюдателей.
// Подробнее об этом можно узнать в знаменитой книге « Шаблоны проектирования: элементы повторно используемого объектно-ориентированного программного обеспечения» ,
// также известной как «книга Банды четырех».
//
// RxJS черпает вдохновение из этого шаблона для своей методологии публикации-подписки, ориентированной на асинхронные программы,
// но добавляет несколько дополнительных функций «из коробки», таких как сигналы, указывающие на завершение потока,
// ленивая инициализация, отмена, управление ресурсами и утилизация. Позже мы рассмотрим компоненты потока RxJS.


///Pipe(конвейер) — позволяет преобразовывать заданные входные данные в желаемые выходные данные.
// По сути, именно здесь будет выполняться ваша бизнес-логика

////Самая сложная часть асинхронного кода — это работа с задержками и временем ожидания.


// RxJS не только обрабатывает последовательные события, но и, используя ту же модель программирования,
// может с такой же лёгкостью работать с асинхронными событиями (с ограничением по времени).
// Это означает, что тот же уровень рассуждений, что применяется к линейным программам, может быть применён и к нелинейным программам
// с задержками и временем ожидания.



///КОМПОНЕНТЫ ПОТОКА (ФОРМАЛЬНО)/
//Producers - Производители
// Consumers - Потребители
// Data pipeline - Конвейер данных
// Time - Время


///Одно из преимуществ RxJS заключается в возможности манипулировать данными или редактировать их по мере их передачи от производителя к потребителю.
// Именно здесь в игру вступает список методов (известных как наблюдаемые операторы - observable operators).

///Неявным фактором, лежащим в основе всего этого, является время. В основе всего, что связано с RxJS, всегда лежит концепция времени,
// которую можно использовать для управления потоками.

////функциональное программирование ставит поведение в центр всего, а функции — в качестве основной единицы работы.
///Реактивное программирование, с другой стороны, требует от вас рассматривать данные как постоянно текущий поток изменений ,
// а не как монолитные типы данных или коллекции, хранящие всё состояние приложения.

/// Если вам нужна дополнительная информация о функциональном программировании и его темах, вы можете подробно ознакомиться с ними
// в книге Луиса Атенсио «Функциональное программирование на JavaScript» (Manning, 2016).

/////Типичным решением проблемы такого рода было бы использование EventEmitter
//Но излучатель событий не останавливается после одного события; вместо этого он может продолжать вызывать зарегистрированные
// обратные вызовы для каждого поступающего события, создавая практически бесконечный поток событий.

//Вместо этого вы можете использовать RxJS для обёртки генераторов событий, сохраняя все его преимущества и универсальность
import {fromEvent} from "rxjs";

const link = document.querySelector('#google');

const clickStream = fromEvent(link, 'click')
    .map(event => event.currentTarget.getAttribute('href'))
    .subscribe(console.log); /-> http://www.google.com

//////
///Observables - push-based collections

/////В главе 7 вы узнаете, что можно повторно выполнить a Promise Observableи принудительно выполнить его много раз, вложив его в другой Observable, который поддерживает повторные попытки.


